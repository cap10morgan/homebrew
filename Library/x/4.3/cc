#!/usr/bin/ruby
#TODO make it work with our GCC
#TODO look for formula that adjust LDFLAGS/CPPFLAGS for deps and make them work
#TODO try to create /usr/local/opt before merge
#TODO? If we find -mmacosx-version-min=10.8, change sdkroot? warn visibly if no such SDK?

def ccc? flags
  flags.split('').all?{|c| ENV['HOMEBREW_CCC'].include? c } if ENV['HOMEBREW_CCC']
end
def macos
  tst = Proc.new{|v| v.strip if v =~ /10\.\d/ }
  tst.call(ENV['HOMEBREW_MACOS']) || tst.call(ENV['MACOS_DEPLOYMENT_TARGET']) || tst.call(`/usr/bin/sw_vers -productVersion`)
end
def nclt?
  $sdkroot != nil
end
def cmake_prefixes
  @prefixes ||= ENV['CMAKE_PREFIX_PATH'].split(':').reject do |path|
    case path
    when '/usr/local'
      !nclt?
    when '/usr', '/', "#$sdkroot/usr"
      true
    end
  end
end
def cc
  case cc = ENV['CC'].basename.chuzzle when /gcc/
    cc
  else
    'clang'
  end
end

class Cmd
  def initialize path, args
    @cmd = path.basename.freeze
    @args = args.freeze
  end
  def mode
    if @cmd == 'cpp' or @cmd == 'ld'
      @cmd.to_sym
    elsif @args.include? '-c'
      :cc
    else
      :ccld
    end
  end
  def tool
    case @cmd
      when 'clang', 'cc' then 'clang'
      when 'clang++', 'c++' then 'clang++'
      when /gcc/ then 'gcc'
      when /g\+\+/ then 'g++'
      when 'ld', 'cpp' then cc
    else
      abort "Unknown command: #{@cmd}"
    end
  end
  def args
    args = if ccc? 'O'
      parsed_args
    else
      @args.dup
    end
    args.unshift("--sysroot=#$sdkroot") if nclt?
    case mode
    when :cpp
      %w{-E} + cppflags + args
    when :ld
      ldflags + args
    when :cc
      cflags + cppflags + args
    when :ccld
      cflags + cppflags + ldflags + args
    end.compact
  end
  def xcrun
    if nclt?
      %W{xcrun #{tool}}
    else
      %W{/usr/bin/#{tool}}
    end
  end
  def parsed_args
    args = []
    origargs = @args.dup
    while arg = origargs.shift
      case arg
      when '-arch', /^-Xarch_/
        origargs.shift
      when /^-g\d?/, /^-gstabs\d+/, '-gstabs+', /^-ggdb\d?/, '-gdwarf-2',
           /^-march=.+/, /^-mtune=.+/, '-m64', '-m32',
           /^-O[0-9zs]/, '-fast',
           %r{^-[IL]/opt/local}, %r{^-[IL]/sw},
           '-pedantic', '-pedantic-errors'
      when /^-W.*/
        args << arg if arg =~ /^-Wl,/
      when /^-I(.*)/
        args << arg unless cmake_prefixes.include? $1.cleanpath
      else
        args << arg
      end
    end
    args
  end
  def cflags
    if ccc? 'Ob'
      %w{-mtune=generic -Oz}
    elsif ccc? 'O'
      u = '-arch i386 -arch x86_64' if ccc? 'u'
      c = case tool when 'clang', 'clang++' then '-march=native' end
      %w{-pipe -w -Os} << u << c
    else
      []
    end
  end
  def ldflags
    cmake_prefixes.map{|prefix| "#{prefix}/lib" }.to_flags('-L')
  end
  def cppflags
    all = cmake_prefixes.map{|prefix| "#{prefix}/include" }
    opt = all.select{|prefix| prefix =~ %r{^#$brewfix/opt} }
    sys = all - opt + ENV['CMAKE_INCLUDE_PATH'].split(':')
    # we want our keg-only includes to be found before system includes so that
    # they override the system options.
    sys.to_flags('-isystem') + opt.to_flags('-I')
  end
end

####################################################################### extend
class String
  def directory?; File.directory? self end
  def basename; File.basename self end
  def chuzzle; s = chomp; s unless s.empty? end
  def cleanpath; require 'pathname'; Pathname.new(self).realpath.to_s rescue self end
end
class NilClass
  def chuzzle; end
  def directory?; false end
  def split(x); [] end
end
class Array
  def to_flags prefix
    select{|path| path.directory? }.uniq.map{|path| prefix+path }
  end
end
module Kernel extend self
  alias :_exec :exec
  def exec *args
    path = File.expand_path('~/Library/Logs/Homebrew/cc.log')
    open(path, 'a'){|f| f.puts(args.join(' ')); f.puts }
    _exec *args
  end
end if ENV['HOMEBREW_LOG']

####################################################################### global
$brewfix = "#{__FILE__}/../../../../".cleanpath.freeze
$sdkroot = ENV['HOMEBREW_SDKROOT'].freeze

######################################################################### main
cmd = Cmd.new($0, ARGV)
exec *(cmd.xcrun + cmd.args)
